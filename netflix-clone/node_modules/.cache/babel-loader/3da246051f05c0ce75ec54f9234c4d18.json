{"ast":null,"code":"'use strict';\n\nconst _ = {\n  sum: require('lodash/sum'),\n  flatten: require('lodash/flatten')\n};\n\nconst chalk = require('chalk');\n/**\n * The paginator returns a subset of the choices if the list is too long.\n */\n\n\nclass Paginator {\n  constructor(screen) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      isInfinite = true\n    } = options;\n    this.lastIndex = 0;\n    this.screen = screen;\n    this.isInfinite = isInfinite;\n  }\n\n  paginate(output, active, pageSize) {\n    pageSize = pageSize || 7;\n    let lines = output.split('\\n');\n\n    if (this.screen) {\n      lines = this.screen.breakLines(lines);\n      active = _.sum(lines.map(lineParts => lineParts.length).splice(0, active));\n      lines = _.flatten(lines);\n    } // Make sure there's enough lines to paginate\n\n\n    if (lines.length <= pageSize) {\n      return output;\n    }\n\n    const visibleLines = this.isInfinite ? this.getInfiniteLines(lines, active, pageSize) : this.getFiniteLines(lines, active, pageSize);\n    this.lastIndex = active;\n    return visibleLines.join('\\n') + '\\n' + chalk.dim('(Move up and down to reveal more choices)');\n  }\n\n  getInfiniteLines(lines, active, pageSize) {\n    if (this.pointer === undefined) {\n      this.pointer = 0;\n    }\n\n    const middleOfList = Math.floor(pageSize / 2); // Move the pointer only when the user go down and limit it to the middle of the list\n\n    if (this.pointer < middleOfList && this.lastIndex < active && active - this.lastIndex < pageSize) {\n      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);\n    } // Duplicate the lines so it give an infinite list look\n\n\n    const infinite = _.flatten([lines, lines, lines]);\n\n    const topIndex = Math.max(0, active + lines.length - this.pointer);\n    return infinite.splice(topIndex, pageSize);\n  }\n\n  getFiniteLines(lines, active, pageSize) {\n    let topIndex = active - pageSize / 2;\n\n    if (topIndex < 0) {\n      topIndex = 0;\n    } else if (topIndex + pageSize > lines.length) {\n      topIndex = lines.length - pageSize;\n    }\n\n    return lines.splice(topIndex, pageSize);\n  }\n\n}\n\nmodule.exports = Paginator;","map":{"version":3,"sources":["C:/Users/DELL/OneDrive/Desktop/React/netflix-clone/node_modules/firebase-tools/node_modules/inquirer/lib/utils/paginator.js"],"names":["_","sum","require","flatten","chalk","Paginator","constructor","screen","options","isInfinite","lastIndex","paginate","output","active","pageSize","lines","split","breakLines","map","lineParts","length","splice","visibleLines","getInfiniteLines","getFiniteLines","join","dim","pointer","undefined","middleOfList","Math","floor","min","infinite","topIndex","max","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,CAAC,GAAG;AACRC,EAAAA,GAAG,EAAEC,OAAO,CAAC,YAAD,CADJ;AAERC,EAAAA,OAAO,EAAED,OAAO,CAAC,gBAAD;AAFR,CAAV;;AAIA,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;AAEA;AACA;AACA;;;AAEA,MAAMG,SAAN,CAAgB;AACdC,EAAAA,WAAW,CAACC,MAAD,EAAuB;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAChC,UAAM;AAAEC,MAAAA,UAAU,GAAG;AAAf,QAAwBD,OAA9B;AACA,SAAKE,SAAL,GAAiB,CAAjB;AACA,SAAKH,MAAL,GAAcA,MAAd;AACA,SAAKE,UAAL,GAAkBA,UAAlB;AACD;;AAEDE,EAAAA,QAAQ,CAACC,MAAD,EAASC,MAAT,EAAiBC,QAAjB,EAA2B;AACjCA,IAAAA,QAAQ,GAAGA,QAAQ,IAAI,CAAvB;AACA,QAAIC,KAAK,GAAGH,MAAM,CAACI,KAAP,CAAa,IAAb,CAAZ;;AAEA,QAAI,KAAKT,MAAT,EAAiB;AACfQ,MAAAA,KAAK,GAAG,KAAKR,MAAL,CAAYU,UAAZ,CAAuBF,KAAvB,CAAR;AACAF,MAAAA,MAAM,GAAGb,CAAC,CAACC,GAAF,CAAMc,KAAK,CAACG,GAAN,CAAWC,SAAD,IAAeA,SAAS,CAACC,MAAnC,EAA2CC,MAA3C,CAAkD,CAAlD,EAAqDR,MAArD,CAAN,CAAT;AACAE,MAAAA,KAAK,GAAGf,CAAC,CAACG,OAAF,CAAUY,KAAV,CAAR;AACD,KARgC,CAUjC;;;AACA,QAAIA,KAAK,CAACK,MAAN,IAAgBN,QAApB,EAA8B;AAC5B,aAAOF,MAAP;AACD;;AACD,UAAMU,YAAY,GAAG,KAAKb,UAAL,GACjB,KAAKc,gBAAL,CAAsBR,KAAtB,EAA6BF,MAA7B,EAAqCC,QAArC,CADiB,GAEjB,KAAKU,cAAL,CAAoBT,KAApB,EAA2BF,MAA3B,EAAmCC,QAAnC,CAFJ;AAGA,SAAKJ,SAAL,GAAiBG,MAAjB;AACA,WACES,YAAY,CAACG,IAAb,CAAkB,IAAlB,IACA,IADA,GAEArB,KAAK,CAACsB,GAAN,CAAU,2CAAV,CAHF;AAKD;;AAEDH,EAAAA,gBAAgB,CAACR,KAAD,EAAQF,MAAR,EAAgBC,QAAhB,EAA0B;AACxC,QAAI,KAAKa,OAAL,KAAiBC,SAArB,EAAgC;AAC9B,WAAKD,OAAL,GAAe,CAAf;AACD;;AACD,UAAME,YAAY,GAAGC,IAAI,CAACC,KAAL,CAAWjB,QAAQ,GAAG,CAAtB,CAArB,CAJwC,CAKxC;;AACA,QACE,KAAKa,OAAL,GAAeE,YAAf,IACA,KAAKnB,SAAL,GAAiBG,MADjB,IAEAA,MAAM,GAAG,KAAKH,SAAd,GAA0BI,QAH5B,EAIE;AACA,WAAKa,OAAL,GAAeG,IAAI,CAACE,GAAL,CAASH,YAAT,EAAuB,KAAKF,OAAL,GAAed,MAAf,GAAwB,KAAKH,SAApD,CAAf;AACD,KAZuC,CAcxC;;;AACA,UAAMuB,QAAQ,GAAGjC,CAAC,CAACG,OAAF,CAAU,CAACY,KAAD,EAAQA,KAAR,EAAeA,KAAf,CAAV,CAAjB;;AACA,UAAMmB,QAAQ,GAAGJ,IAAI,CAACK,GAAL,CAAS,CAAT,EAAYtB,MAAM,GAAGE,KAAK,CAACK,MAAf,GAAwB,KAAKO,OAAzC,CAAjB;AAEA,WAAOM,QAAQ,CAACZ,MAAT,CAAgBa,QAAhB,EAA0BpB,QAA1B,CAAP;AACD;;AAEDU,EAAAA,cAAc,CAACT,KAAD,EAAQF,MAAR,EAAgBC,QAAhB,EAA0B;AACtC,QAAIoB,QAAQ,GAAGrB,MAAM,GAAGC,QAAQ,GAAG,CAAnC;;AACA,QAAIoB,QAAQ,GAAG,CAAf,EAAkB;AAChBA,MAAAA,QAAQ,GAAG,CAAX;AACD,KAFD,MAEO,IAAIA,QAAQ,GAAGpB,QAAX,GAAsBC,KAAK,CAACK,MAAhC,EAAwC;AAC7Cc,MAAAA,QAAQ,GAAGnB,KAAK,CAACK,MAAN,GAAeN,QAA1B;AACD;;AACD,WAAOC,KAAK,CAACM,MAAN,CAAaa,QAAb,EAAuBpB,QAAvB,CAAP;AACD;;AA9Da;;AAiEhBsB,MAAM,CAACC,OAAP,GAAiBhC,SAAjB","sourcesContent":["'use strict';\n\nconst _ = {\n  sum: require('lodash/sum'),\n  flatten: require('lodash/flatten'),\n};\nconst chalk = require('chalk');\n\n/**\n * The paginator returns a subset of the choices if the list is too long.\n */\n\nclass Paginator {\n  constructor(screen, options = {}) {\n    const { isInfinite = true } = options;\n    this.lastIndex = 0;\n    this.screen = screen;\n    this.isInfinite = isInfinite;\n  }\n\n  paginate(output, active, pageSize) {\n    pageSize = pageSize || 7;\n    let lines = output.split('\\n');\n\n    if (this.screen) {\n      lines = this.screen.breakLines(lines);\n      active = _.sum(lines.map((lineParts) => lineParts.length).splice(0, active));\n      lines = _.flatten(lines);\n    }\n\n    // Make sure there's enough lines to paginate\n    if (lines.length <= pageSize) {\n      return output;\n    }\n    const visibleLines = this.isInfinite\n      ? this.getInfiniteLines(lines, active, pageSize)\n      : this.getFiniteLines(lines, active, pageSize);\n    this.lastIndex = active;\n    return (\n      visibleLines.join('\\n') +\n      '\\n' +\n      chalk.dim('(Move up and down to reveal more choices)')\n    );\n  }\n\n  getInfiniteLines(lines, active, pageSize) {\n    if (this.pointer === undefined) {\n      this.pointer = 0;\n    }\n    const middleOfList = Math.floor(pageSize / 2);\n    // Move the pointer only when the user go down and limit it to the middle of the list\n    if (\n      this.pointer < middleOfList &&\n      this.lastIndex < active &&\n      active - this.lastIndex < pageSize\n    ) {\n      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);\n    }\n\n    // Duplicate the lines so it give an infinite list look\n    const infinite = _.flatten([lines, lines, lines]);\n    const topIndex = Math.max(0, active + lines.length - this.pointer);\n\n    return infinite.splice(topIndex, pageSize);\n  }\n\n  getFiniteLines(lines, active, pageSize) {\n    let topIndex = active - pageSize / 2;\n    if (topIndex < 0) {\n      topIndex = 0;\n    } else if (topIndex + pageSize > lines.length) {\n      topIndex = lines.length - pageSize;\n    }\n    return lines.splice(topIndex, pageSize);\n  }\n}\n\nmodule.exports = Paginator;\n"]},"metadata":{},"sourceType":"script"}