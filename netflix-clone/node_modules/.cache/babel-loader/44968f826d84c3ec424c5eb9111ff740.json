{"ast":null,"code":"\"use strict\";\n\nconst util_1 = require(\"util\");\n\nconst escodegen_1 = require(\"escodegen\");\n\nconst esprima_1 = require(\"esprima\");\n\nconst ast_types_1 = require(\"ast-types\");\n\nconst vm2_1 = require(\"vm2\");\n/**\n * Compiles sync JavaScript code into JavaScript with async Functions.\n *\n * @param {String} code JavaScript string to convert\n * @param {Array} names Array of function names to add `await` operators to\n * @return {String} Converted JavaScript string with async/await injected\n * @api public\n */\n\n\nfunction degenerator(code, _names) {\n  if (!Array.isArray(_names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  } // Duplicate the `names` array since it's rude to augment the user args\n\n\n  const names = _names.slice(0);\n\n  const ast = esprima_1.parseScript(code); // First pass is to find the `function` nodes and turn them into async or\n  // generator functions only if their body includes `CallExpressions` to\n  // function in `names`. We also add the names of the functions to the `names`\n  // array. We'll iterate several time, as every iteration might add new items\n  // to the `names` array, until no new names were added in the iteration.\n\n  let lastNamesLength = 0;\n\n  do {\n    lastNamesLength = names.length;\n    ast_types_1.visit(ast, {\n      visitVariableDeclaration(path) {\n        if (path.node.declarations) {\n          for (let i = 0; i < path.node.declarations.length; i++) {\n            const declaration = path.node.declarations[i];\n\n            if (ast_types_1.namedTypes.VariableDeclarator.check(declaration) && ast_types_1.namedTypes.Identifier.check(declaration.init) && ast_types_1.namedTypes.Identifier.check(declaration.id) && checkName(declaration.init.name, names) && !checkName(declaration.id.name, names)) {\n              names.push(declaration.id.name);\n            }\n          }\n        }\n\n        return false;\n      },\n\n      visitAssignmentExpression(path) {\n        if (ast_types_1.namedTypes.Identifier.check(path.node.left) && ast_types_1.namedTypes.Identifier.check(path.node.right) && checkName(path.node.right.name, names) && !checkName(path.node.left.name, names)) {\n          names.push(path.node.left.name);\n        }\n\n        return false;\n      },\n\n      visitFunction(path) {\n        if (path.node.id) {\n          let shouldDegenerate = false;\n          ast_types_1.visit(path.node, {\n            visitCallExpression(path) {\n              if (checkNames(path.node, names)) {\n                shouldDegenerate = true;\n              }\n\n              return false;\n            }\n\n          });\n\n          if (!shouldDegenerate) {\n            return false;\n          } // Got a \"function\" expression/statement,\n          // convert it into an async function\n\n\n          path.node.async = true; // Add function name to `names` array\n\n          if (!checkName(path.node.id.name, names)) {\n            names.push(path.node.id.name);\n          }\n        }\n\n        this.traverse(path);\n      }\n\n    });\n  } while (lastNamesLength !== names.length); // Second pass is for adding `await`/`yield` statements to any function\n  // invocations that match the given `names` array.\n\n\n  ast_types_1.visit(ast, {\n    visitCallExpression(path) {\n      if (checkNames(path.node, names)) {\n        // A \"function invocation\" expression,\n        // we need to inject a `AwaitExpression`/`YieldExpression`\n        const delegate = false;\n        const {\n          name,\n          parent: {\n            node: pNode\n          }\n        } = path;\n        const expr = ast_types_1.builders.awaitExpression(path.node, delegate);\n\n        if (ast_types_1.namedTypes.CallExpression.check(pNode)) {\n          pNode.arguments[name] = expr;\n        } else {\n          pNode[name] = expr;\n        }\n      }\n\n      this.traverse(path);\n    }\n\n  });\n  return escodegen_1.generate(ast);\n}\n\n(function (degenerator) {\n  function compile(code, returnName, names) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const compiled = degenerator(code, names);\n    const vm = new vm2_1.VM(options);\n    const script = new vm2_1.VMScript(`${compiled};${returnName}`, {\n      filename: options.filename\n    });\n    const fn = vm.run(script);\n\n    if (typeof fn !== 'function') {\n      throw new Error(`Expected a \"function\" to be returned for \\`${returnName}\\`, but got \"${typeof fn}\"`);\n    }\n\n    const r = function () {\n      var _a;\n\n      try {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        const p = fn.apply(this, args);\n\n        if (typeof ((_a = p) === null || _a === void 0 ? void 0 : _a.then) === 'function') {\n          return p;\n        }\n\n        return Promise.resolve(p);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    };\n\n    Object.defineProperty(r, 'toString', {\n      value: fn.toString.bind(fn),\n      enumerable: false\n    });\n    return r;\n  }\n\n  degenerator.compile = compile;\n})(degenerator || (degenerator = {}));\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\n\nfunction checkNames(_ref, names) {\n  let {\n    callee\n  } = _ref;\n  let name;\n\n  if (ast_types_1.namedTypes.Identifier.check(callee)) {\n    name = callee.name;\n  } else if (ast_types_1.namedTypes.MemberExpression.check(callee)) {\n    if (ast_types_1.namedTypes.Identifier.check(callee.object) && ast_types_1.namedTypes.Identifier.check(callee.property)) {\n      name = `${callee.object.name}.${callee.property.name}`;\n    } else {\n      return false;\n    }\n  } else if (ast_types_1.namedTypes.FunctionExpression.check(callee)) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error(`Don't know how to get name for: ${callee.type}`);\n  }\n\n  return checkName(name, names);\n}\n\nfunction checkName(name, names) {\n  // now that we have the `name`, check if any entries match in the `names` array\n  for (let i = 0; i < names.length; i++) {\n    const n = names[i];\n\n    if (util_1.isRegExp(n)) {\n      if (n.test(name)) {\n        return true;\n      }\n    } else if (name === n) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nmodule.exports = degenerator;","map":{"version":3,"mappings":"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","names":["degenerator","code","_names","Array","isArray","TypeError","names","slice","ast","esprima_1","lastNamesLength","length","ast_types_1","visitVariableDeclaration","path","node","declarations","i","declaration","VariableDeclarator","check","Identifier","init","id","checkName","name","push","visitAssignmentExpression","left","right","visitFunction","shouldDegenerate","visitCallExpression","checkNames","async","traverse","delegate","parent","pNode","expr","awaitExpression","CallExpression","arguments","escodegen_1","compile","returnName","options","compiled","vm","vm2_1","script","filename","fn","run","Error","r","args","p","apply","_a","then","Promise","resolve","err","reject","Object","defineProperty","value","toString","bind","enumerable","callee","MemberExpression","object","property","FunctionExpression","type","n","util_1","test","module"],"sources":["../../src/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}