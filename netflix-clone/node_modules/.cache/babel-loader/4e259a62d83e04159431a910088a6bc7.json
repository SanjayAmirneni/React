{"ast":null,"code":"'use strict';\n\nconst _ = {\n  last: require('lodash/last'),\n  flatten: require('lodash/flatten')\n};\n\nconst util = require('./readline');\n\nconst cliWidth = require('cli-width');\n\nconst stripAnsi = require('strip-ansi');\n\nconst stringWidth = require('string-width');\n\nconst ora = require('ora');\n\nfunction height(content) {\n  return content.split('\\n').length;\n}\n\nfunction lastLine(content) {\n  return _.last(content.split('\\n'));\n}\n\nclass ScreenManager {\n  constructor(rl) {\n    // These variables are keeping information to allow correct prompt re-rendering\n    this.height = 0;\n    this.extraLinesUnderPrompt = 0;\n    this.rl = rl;\n  }\n\n  renderWithSpinner(content, bottomContent) {\n    if (this.spinnerId) {\n      clearInterval(this.spinnerId);\n    }\n\n    let spinner;\n    let contentFunc;\n    let bottomContentFunc;\n\n    if (bottomContent) {\n      spinner = ora(bottomContent);\n\n      contentFunc = () => content;\n\n      bottomContentFunc = () => spinner.frame();\n    } else {\n      spinner = ora(content);\n\n      contentFunc = () => spinner.frame();\n\n      bottomContentFunc = () => '';\n    }\n\n    this.spinnerId = setInterval(() => this.render(contentFunc(), bottomContentFunc(), true), spinner.interval);\n  }\n\n  render(content, bottomContent) {\n    let spinning = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (this.spinnerId && !spinning) {\n      clearInterval(this.spinnerId);\n    }\n\n    this.rl.output.unmute();\n    this.clean(this.extraLinesUnderPrompt);\n    /**\n     * Write message to screen and setPrompt to control backspace\n     */\n\n    const promptLine = lastLine(content);\n    const rawPromptLine = stripAnsi(promptLine); // Remove the rl.line from our prompt. We can't rely on the content of\n    // rl.line (mainly because of the password prompt), so just rely on it's\n    // length.\n\n    let prompt = rawPromptLine;\n\n    if (this.rl.line.length) {\n      prompt = prompt.slice(0, -this.rl.line.length);\n    }\n\n    this.rl.setPrompt(prompt); // SetPrompt will change cursor position, now we can get correct value\n\n    const cursorPos = this.rl._getCursorPos();\n\n    const width = this.normalizedCliWidth();\n    content = this.forceLineReturn(content, width);\n\n    if (bottomContent) {\n      bottomContent = this.forceLineReturn(bottomContent, width);\n    } // Manually insert an extra line if we're at the end of the line.\n    // This prevent the cursor from appearing at the beginning of the\n    // current line.\n\n\n    if (rawPromptLine.length % width === 0) {\n      content += '\\n';\n    }\n\n    const fullContent = content + (bottomContent ? '\\n' + bottomContent : '');\n    this.rl.output.write(fullContent);\n    /**\n     * Re-adjust the cursor at the correct position.\n     */\n    // We need to consider parts of the prompt under the cursor as part of the bottom\n    // content in order to correctly cleanup and re-render.\n\n    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;\n    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);\n\n    if (bottomContentHeight > 0) {\n      util.up(this.rl, bottomContentHeight);\n    } // Reset cursor at the beginning of the line\n\n\n    util.left(this.rl, stringWidth(lastLine(fullContent))); // Adjust cursor on the right\n\n    if (cursorPos.cols > 0) {\n      util.right(this.rl, cursorPos.cols);\n    }\n    /**\n     * Set up state for next re-rendering\n     */\n\n\n    this.extraLinesUnderPrompt = bottomContentHeight;\n    this.height = height(fullContent);\n    this.rl.output.mute();\n  }\n\n  clean(extraLines) {\n    if (extraLines > 0) {\n      util.down(this.rl, extraLines);\n    }\n\n    util.clearLine(this.rl, this.height);\n  }\n\n  done() {\n    this.rl.setPrompt('');\n    this.rl.output.unmute();\n    this.rl.output.write('\\n');\n  }\n\n  releaseCursor() {\n    if (this.extraLinesUnderPrompt > 0) {\n      util.down(this.rl, this.extraLinesUnderPrompt);\n    }\n  }\n\n  normalizedCliWidth() {\n    const width = cliWidth({\n      defaultWidth: 80,\n      output: this.rl.output\n    });\n    return width;\n  }\n\n  breakLines(lines, width) {\n    // Break lines who're longer than the cli width so we can normalize the natural line\n    // returns behavior across terminals.\n    width = width || this.normalizedCliWidth();\n    const regex = new RegExp('(?:(?:\\\\033[[0-9;]*m)*.?){1,' + width + '}', 'g');\n    return lines.map(line => {\n      const chunk = line.match(regex); // Last match is always empty\n\n      chunk.pop();\n      return chunk || '';\n    });\n  }\n\n  forceLineReturn(content, width) {\n    width = width || this.normalizedCliWidth();\n    return _.flatten(this.breakLines(content.split('\\n'), width)).join('\\n');\n  }\n\n}\n\nmodule.exports = ScreenManager;","map":{"version":3,"sources":["C:/Users/DELL/OneDrive/Desktop/React/netflix-clone/node_modules/firebase-tools/node_modules/inquirer/lib/utils/screen-manager.js"],"names":["_","last","require","flatten","util","cliWidth","stripAnsi","stringWidth","ora","height","content","split","length","lastLine","ScreenManager","constructor","rl","extraLinesUnderPrompt","renderWithSpinner","bottomContent","spinnerId","clearInterval","spinner","contentFunc","bottomContentFunc","frame","setInterval","render","interval","spinning","output","unmute","clean","promptLine","rawPromptLine","prompt","line","slice","setPrompt","cursorPos","_getCursorPos","width","normalizedCliWidth","forceLineReturn","fullContent","write","promptLineUpDiff","Math","floor","rows","bottomContentHeight","up","left","cols","right","mute","extraLines","down","clearLine","done","releaseCursor","defaultWidth","breakLines","lines","regex","RegExp","map","chunk","match","pop","join","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst _ = {\n  last: require('lodash/last'),\n  flatten: require('lodash/flatten'),\n};\nconst util = require('./readline');\nconst cliWidth = require('cli-width');\nconst stripAnsi = require('strip-ansi');\nconst stringWidth = require('string-width');\nconst ora = require('ora');\n\nfunction height(content) {\n  return content.split('\\n').length;\n}\n\nfunction lastLine(content) {\n  return _.last(content.split('\\n'));\n}\n\nclass ScreenManager {\n  constructor(rl) {\n    // These variables are keeping information to allow correct prompt re-rendering\n    this.height = 0;\n    this.extraLinesUnderPrompt = 0;\n\n    this.rl = rl;\n  }\n\n  renderWithSpinner(content, bottomContent) {\n    if (this.spinnerId) {\n      clearInterval(this.spinnerId);\n    }\n\n    let spinner;\n    let contentFunc;\n    let bottomContentFunc;\n\n    if (bottomContent) {\n      spinner = ora(bottomContent);\n      contentFunc = () => content;\n      bottomContentFunc = () => spinner.frame();\n    } else {\n      spinner = ora(content);\n      contentFunc = () => spinner.frame();\n      bottomContentFunc = () => '';\n    }\n\n    this.spinnerId = setInterval(\n      () => this.render(contentFunc(), bottomContentFunc(), true),\n      spinner.interval\n    );\n  }\n\n  render(content, bottomContent, spinning = false) {\n    if (this.spinnerId && !spinning) {\n      clearInterval(this.spinnerId);\n    }\n\n    this.rl.output.unmute();\n    this.clean(this.extraLinesUnderPrompt);\n\n    /**\n     * Write message to screen and setPrompt to control backspace\n     */\n\n    const promptLine = lastLine(content);\n    const rawPromptLine = stripAnsi(promptLine);\n\n    // Remove the rl.line from our prompt. We can't rely on the content of\n    // rl.line (mainly because of the password prompt), so just rely on it's\n    // length.\n    let prompt = rawPromptLine;\n    if (this.rl.line.length) {\n      prompt = prompt.slice(0, -this.rl.line.length);\n    }\n\n    this.rl.setPrompt(prompt);\n\n    // SetPrompt will change cursor position, now we can get correct value\n    const cursorPos = this.rl._getCursorPos();\n    const width = this.normalizedCliWidth();\n\n    content = this.forceLineReturn(content, width);\n    if (bottomContent) {\n      bottomContent = this.forceLineReturn(bottomContent, width);\n    }\n\n    // Manually insert an extra line if we're at the end of the line.\n    // This prevent the cursor from appearing at the beginning of the\n    // current line.\n    if (rawPromptLine.length % width === 0) {\n      content += '\\n';\n    }\n\n    const fullContent = content + (bottomContent ? '\\n' + bottomContent : '');\n    this.rl.output.write(fullContent);\n\n    /**\n     * Re-adjust the cursor at the correct position.\n     */\n\n    // We need to consider parts of the prompt under the cursor as part of the bottom\n    // content in order to correctly cleanup and re-render.\n    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;\n    const bottomContentHeight =\n      promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);\n    if (bottomContentHeight > 0) {\n      util.up(this.rl, bottomContentHeight);\n    }\n\n    // Reset cursor at the beginning of the line\n    util.left(this.rl, stringWidth(lastLine(fullContent)));\n\n    // Adjust cursor on the right\n    if (cursorPos.cols > 0) {\n      util.right(this.rl, cursorPos.cols);\n    }\n\n    /**\n     * Set up state for next re-rendering\n     */\n    this.extraLinesUnderPrompt = bottomContentHeight;\n    this.height = height(fullContent);\n\n    this.rl.output.mute();\n  }\n\n  clean(extraLines) {\n    if (extraLines > 0) {\n      util.down(this.rl, extraLines);\n    }\n\n    util.clearLine(this.rl, this.height);\n  }\n\n  done() {\n    this.rl.setPrompt('');\n    this.rl.output.unmute();\n    this.rl.output.write('\\n');\n  }\n\n  releaseCursor() {\n    if (this.extraLinesUnderPrompt > 0) {\n      util.down(this.rl, this.extraLinesUnderPrompt);\n    }\n  }\n\n  normalizedCliWidth() {\n    const width = cliWidth({\n      defaultWidth: 80,\n      output: this.rl.output,\n    });\n    return width;\n  }\n\n  breakLines(lines, width) {\n    // Break lines who're longer than the cli width so we can normalize the natural line\n    // returns behavior across terminals.\n    width = width || this.normalizedCliWidth();\n    const regex = new RegExp('(?:(?:\\\\033[[0-9;]*m)*.?){1,' + width + '}', 'g');\n    return lines.map((line) => {\n      const chunk = line.match(regex);\n      // Last match is always empty\n      chunk.pop();\n      return chunk || '';\n    });\n  }\n\n  forceLineReturn(content, width) {\n    width = width || this.normalizedCliWidth();\n    return _.flatten(this.breakLines(content.split('\\n'), width)).join('\\n');\n  }\n}\n\nmodule.exports = ScreenManager;\n"]},"metadata":{},"sourceType":"script"}