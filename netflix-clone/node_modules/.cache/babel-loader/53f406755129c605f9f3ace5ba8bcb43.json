{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\n\nconst ftp_1 = __importDefault(require(\"ftp\"));\n\nconst path_1 = require(\"path\");\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst notfound_1 = __importDefault(require(\"./notfound\"));\n\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\n\nconst debug = debug_1.default('get-uri:ftp');\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n */\n\nfunction get(parsed, opts) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      cache\n    } = opts;\n    const filepath = parsed.pathname;\n    let lastModified = null;\n\n    if (!filepath) {\n      throw new TypeError('No \"pathname\"!');\n    }\n\n    const client = new ftp_1.default();\n    client.once('greeting', greeting => {\n      debug('FTP greeting: %o', greeting);\n    });\n\n    function onend() {\n      // close the FTP client socket connection\n      client.end();\n    }\n\n    try {\n      opts.host = parsed.hostname || parsed.host || 'localhost';\n      opts.port = parseInt(parsed.port || '0', 10) || 21;\n      opts.debug = debug;\n\n      if (parsed.auth) {\n        const [user, password] = parsed.auth.split(':');\n        opts.user = user;\n        opts.password = password;\n      } // await cb(_ => client.connect(opts, _));\n\n\n      const readyPromise = once_1.default(client, 'ready');\n      client.connect(opts);\n      yield readyPromise; // first we have to figure out the Last Modified date.\n      // try the MDTM command first, which is an optional extension command.\n\n      try {\n        lastModified = yield new Promise((resolve, reject) => {\n          client.lastMod(filepath, (err, res) => {\n            return err ? reject(err) : resolve(res);\n          });\n        });\n      } catch (err) {\n        // handle the \"file not found\" error code\n        if (err.code === 550) {\n          throw new notfound_1.default();\n        }\n      }\n\n      if (!lastModified) {\n        // Try to get the last modified date via the LIST command (uses\n        // more bandwidth, but is more compatible with older FTP servers\n        const list = yield new Promise((resolve, reject) => {\n          client.list(path_1.dirname(filepath), (err, res) => {\n            return err ? reject(err) : resolve(res);\n          });\n        }); // attempt to find the \"entry\" with a matching \"name\"\n\n        const name = path_1.basename(filepath);\n        const entry = list.find(e => e.name === name);\n\n        if (entry) {\n          lastModified = entry.date;\n        }\n      }\n\n      if (lastModified) {\n        if (isNotModified()) {\n          throw new notmodified_1.default();\n        }\n      } else {\n        throw new notfound_1.default();\n      } // XXX: a small timeout seemed necessary otherwise FTP servers\n      // were returning empty sockets for the file occasionally\n      // setTimeout(client.get.bind(client, filepath, onfile), 10);\n\n\n      const rs = yield new Promise((resolve, reject) => {\n        client.get(filepath, (err, res) => {\n          return err ? reject(err) : resolve(res);\n        });\n      });\n      rs.once('end', onend);\n      rs.lastModified = lastModified;\n      return rs;\n    } catch (err) {\n      client.destroy();\n      throw err;\n    } // called when `lastModified` is set, and a \"cache\" stream was provided\n\n\n    function isNotModified() {\n      if (cache && cache.lastModified && lastModified) {\n        return +cache.lastModified === +lastModified;\n      }\n\n      return false;\n    }\n  });\n}\n\nexports.default = get;","map":{"version":3,"mappings":"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","names":["debug","debug_1","get","parsed","opts","cache","filepath","pathname","lastModified","TypeError","client","ftp_1","once","greeting","onend","end","host","hostname","port","parseInt","auth","user","password","split","readyPromise","once_1","connect","Promise","resolve","reject","lastMod","err","res","code","notfound_1","list","path_1","name","entry","find","e","date","isNotModified","notmodified_1","rs","destroy","exports"],"sources":["../src/ftp.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}