{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = exports.setAccessToken = exports.setRefreshToken = void 0;\n\nconst url_1 = require(\"url\");\n\nconst stream_1 = require(\"stream\");\n\nconst ProxyAgent = require(\"proxy-agent\");\n\nconst retry = require(\"retry\");\n\nconst abort_controller_1 = require(\"abort-controller\");\n\nconst node_fetch_1 = require(\"node-fetch\");\n\nconst util_1 = require(\"util\");\n\nconst auth = require(\"./auth\");\n\nconst error_1 = require(\"./error\");\n\nconst logger_1 = require(\"./logger\");\n\nconst responseToError = require(\"./responseToError\");\n\nconst pkg = require(\"../package.json\");\n\nconst CLI_VERSION = pkg.version;\nlet accessToken = \"\";\nlet refreshToken = \"\";\n\nfunction setRefreshToken() {\n  let token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  refreshToken = token;\n}\n\nexports.setRefreshToken = setRefreshToken;\n\nfunction setAccessToken() {\n  let token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  accessToken = token;\n}\n\nexports.setAccessToken = setAccessToken;\n\nfunction proxyURIFromEnv() {\n  return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || undefined;\n}\n\nclass Client {\n  constructor(opts) {\n    this.opts = opts;\n\n    if (this.opts.auth === undefined) {\n      this.opts.auth = true;\n    }\n\n    if (this.opts.urlPrefix.endsWith(\"/\")) {\n      this.opts.urlPrefix = this.opts.urlPrefix.substring(0, this.opts.urlPrefix.length - 1);\n    }\n  }\n\n  get(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const reqOptions = Object.assign(options, {\n      method: \"GET\",\n      path\n    });\n    return this.request(reqOptions);\n  }\n\n  post(path, json) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const reqOptions = Object.assign(options, {\n      method: \"POST\",\n      path,\n      body: json\n    });\n    return this.request(reqOptions);\n  }\n\n  patch(path, json) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const reqOptions = Object.assign(options, {\n      method: \"PATCH\",\n      path,\n      body: json\n    });\n    return this.request(reqOptions);\n  }\n\n  put(path, json) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const reqOptions = Object.assign(options, {\n      method: \"PUT\",\n      path,\n      body: json\n    });\n    return this.request(reqOptions);\n  }\n\n  delete(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const reqOptions = Object.assign(options, {\n      method: \"DELETE\",\n      path\n    });\n    return this.request(reqOptions);\n  }\n\n  async request(reqOptions) {\n    if (!reqOptions.responseType) {\n      reqOptions.responseType = \"json\";\n    }\n\n    if (reqOptions.responseType === \"stream\" && !reqOptions.resolveOnHTTPError) {\n      throw new error_1.FirebaseError(\"apiv2 will not handle HTTP errors while streaming and you must set `resolveOnHTTPError` and check for res.status >= 400 on your own\", {\n        exit: 2\n      });\n    }\n\n    let internalReqOptions = Object.assign(reqOptions, {\n      headers: new node_fetch_1.Headers(reqOptions.headers)\n    });\n    internalReqOptions = this.addRequestHeaders(internalReqOptions);\n\n    if (this.opts.auth) {\n      internalReqOptions = await this.addAuthHeader(internalReqOptions);\n    }\n\n    try {\n      return await this.doRequest(internalReqOptions);\n    } catch (thrown) {\n      if (thrown instanceof error_1.FirebaseError) {\n        throw thrown;\n      }\n\n      let err;\n\n      if (thrown instanceof Error) {\n        err = thrown;\n      } else {\n        err = new Error(thrown);\n      }\n\n      throw new error_1.FirebaseError(`Failed to make request: ${err.message}`, {\n        original: err\n      });\n    }\n  }\n\n  addRequestHeaders(reqOptions) {\n    if (!reqOptions.headers) {\n      reqOptions.headers = new node_fetch_1.Headers();\n    }\n\n    reqOptions.headers.set(\"Connection\", \"keep-alive\");\n\n    if (!reqOptions.headers.has(\"User-Agent\")) {\n      reqOptions.headers.set(\"User-Agent\", `FirebaseCLI/${CLI_VERSION}`);\n    }\n\n    reqOptions.headers.set(\"X-Client-Version\", `FirebaseCLI/${CLI_VERSION}`);\n\n    if (!reqOptions.headers.has(\"Content-Type\")) {\n      if (reqOptions.responseType === \"json\") {\n        reqOptions.headers.set(\"Content-Type\", \"application/json\");\n      }\n    }\n\n    return reqOptions;\n  }\n\n  async addAuthHeader(reqOptions) {\n    if (!reqOptions.headers) {\n      reqOptions.headers = new node_fetch_1.Headers();\n    }\n\n    let token;\n\n    if (isLocalInsecureRequest(this.opts.urlPrefix)) {\n      token = \"owner\";\n    } else {\n      token = await this.getAccessToken();\n    }\n\n    reqOptions.headers.set(\"Authorization\", `Bearer ${token}`);\n    return reqOptions;\n  }\n\n  async getAccessToken() {\n    if (accessToken) {\n      return accessToken;\n    }\n\n    const data = await auth.getAccessToken(refreshToken, []);\n    return data.access_token;\n  }\n\n  requestURL(options) {\n    const versionPath = this.opts.apiVersion ? `/${this.opts.apiVersion}` : \"\";\n    return `${this.opts.urlPrefix}${versionPath}${options.path}`;\n  }\n\n  async doRequest(options) {\n    var _a;\n\n    if (!options.path.startsWith(\"/\")) {\n      options.path = \"/\" + options.path;\n    }\n\n    let fetchURL = this.requestURL(options);\n\n    if (options.queryParams) {\n      if (!(options.queryParams instanceof url_1.URLSearchParams)) {\n        const sp = new url_1.URLSearchParams();\n\n        for (const key of Object.keys(options.queryParams)) {\n          const value = options.queryParams[key];\n          sp.append(key, `${value}`);\n        }\n\n        options.queryParams = sp;\n      }\n\n      const queryString = options.queryParams.toString();\n\n      if (queryString) {\n        fetchURL += `?${queryString}`;\n      }\n    }\n\n    const fetchOptions = {\n      headers: options.headers,\n      method: options.method,\n      redirect: options.redirect,\n      compress: options.compress\n    };\n\n    if (this.opts.proxy) {\n      fetchOptions.agent = new ProxyAgent(this.opts.proxy);\n    }\n\n    const envProxy = proxyURIFromEnv();\n\n    if (envProxy) {\n      fetchOptions.agent = new ProxyAgent(envProxy);\n    }\n\n    if (options.signal) {\n      fetchOptions.signal = options.signal;\n    }\n\n    let reqTimeout;\n\n    if (options.timeout) {\n      const controller = new abort_controller_1.default();\n      reqTimeout = setTimeout(() => {\n        controller.abort();\n      }, options.timeout);\n      fetchOptions.signal = controller.signal;\n    }\n\n    if (typeof options.body === \"string\" || isStream(options.body)) {\n      fetchOptions.body = options.body;\n    } else if (options.body !== undefined) {\n      fetchOptions.body = JSON.stringify(options.body);\n    }\n\n    const operationOptions = {\n      retries: ((_a = options.retryCodes) === null || _a === void 0 ? void 0 : _a.length) ? 1 : 2,\n      minTimeout: 1 * 1000,\n      maxTimeout: 5 * 1000\n    };\n\n    if (typeof options.retries === \"number\") {\n      operationOptions.retries = options.retries;\n    }\n\n    if (typeof options.retryMinTimeout === \"number\") {\n      operationOptions.minTimeout = options.retryMinTimeout;\n    }\n\n    if (typeof options.retryMaxTimeout === \"number\") {\n      operationOptions.maxTimeout = options.retryMaxTimeout;\n    }\n\n    const operation = retry.operation(operationOptions);\n    return await new Promise((resolve, reject) => {\n      operation.attempt(async currentAttempt => {\n        var _a;\n\n        let res;\n        let body;\n\n        try {\n          if (currentAttempt > 1) {\n            logger_1.logger.debug(`*** [apiv2] Attempting the request again. Attempt number ${currentAttempt}`);\n          }\n\n          this.logRequest(options);\n\n          try {\n            res = await (0, node_fetch_1.default)(fetchURL, fetchOptions);\n          } catch (thrown) {\n            const err = thrown instanceof Error ? thrown : new Error(thrown);\n            const isAbortError = err.name.includes(\"AbortError\");\n\n            if (isAbortError) {\n              throw new error_1.FirebaseError(`Timeout reached making request to ${fetchURL}`, {\n                original: err\n              });\n            }\n\n            throw new error_1.FirebaseError(`Failed to make request to ${fetchURL}`, {\n              original: err\n            });\n          } finally {\n            if (reqTimeout) {\n              clearTimeout(reqTimeout);\n            }\n          }\n\n          if (options.responseType === \"json\") {\n            const text = await res.text();\n\n            if (!text.length) {\n              body = undefined;\n            } else {\n              try {\n                body = JSON.parse(text);\n              } catch (err) {\n                this.logResponse(res, text, options);\n                throw new error_1.FirebaseError(`Unable to parse JSON: ${err}`);\n              }\n            }\n          } else if (options.responseType === \"xml\") {\n            body = await res.text();\n          } else if (options.responseType === \"stream\") {\n            body = res.body;\n          } else {\n            throw new error_1.FirebaseError(`Unable to interpret response. Please set responseType.`, {\n              exit: 2\n            });\n          }\n        } catch (err) {\n          return err instanceof error_1.FirebaseError ? reject(err) : reject(new error_1.FirebaseError(`${err}`));\n        }\n\n        this.logResponse(res, body, options);\n\n        if (res.status >= 400) {\n          if ((_a = options.retryCodes) === null || _a === void 0 ? void 0 : _a.includes(res.status)) {\n            const err = responseToError({\n              statusCode: res.status\n            }, body) || undefined;\n\n            if (operation.retry(err)) {\n              return;\n            }\n          }\n\n          if (!options.resolveOnHTTPError) {\n            return reject(responseToError({\n              statusCode: res.status\n            }, body));\n          }\n        }\n\n        resolve({\n          status: res.status,\n          response: res,\n          body\n        });\n      });\n    });\n  }\n\n  logRequest(options) {\n    var _a, _b;\n\n    let queryParamsLog = \"[none]\";\n\n    if (options.queryParams) {\n      queryParamsLog = \"[omitted]\";\n\n      if (!((_a = options.skipLog) === null || _a === void 0 ? void 0 : _a.queryParams)) {\n        queryParamsLog = options.queryParams instanceof url_1.URLSearchParams ? options.queryParams.toString() : JSON.stringify(options.queryParams);\n      }\n    }\n\n    const logURL = this.requestURL(options);\n    logger_1.logger.debug(`>>> [apiv2][query] ${options.method} ${logURL} ${queryParamsLog}`);\n\n    if (options.body !== undefined) {\n      let logBody = \"[omitted]\";\n\n      if (!((_b = options.skipLog) === null || _b === void 0 ? void 0 : _b.body)) {\n        logBody = bodyToString(options.body);\n      }\n\n      logger_1.logger.debug(`>>> [apiv2][body] ${options.method} ${logURL} ${logBody}`);\n    }\n  }\n\n  logResponse(res, body, options) {\n    var _a;\n\n    const logURL = this.requestURL(options);\n    logger_1.logger.debug(`<<< [apiv2][status] ${options.method} ${logURL} ${res.status}`);\n    let logBody = \"[omitted]\";\n\n    if (!((_a = options.skipLog) === null || _a === void 0 ? void 0 : _a.resBody)) {\n      logBody = bodyToString(body);\n    }\n\n    logger_1.logger.debug(`<<< [apiv2][body] ${options.method} ${logURL} ${logBody}`);\n  }\n\n}\n\nexports.Client = Client;\n\nfunction isLocalInsecureRequest(urlPrefix) {\n  const u = new url_1.URL(urlPrefix);\n  return u.protocol === \"http:\";\n}\n\nfunction bodyToString(body) {\n  if (isStream(body)) {\n    return \"[stream]\";\n  } else {\n    try {\n      return JSON.stringify(body);\n    } catch (_) {\n      return util_1.default.inspect(body);\n    }\n  }\n}\n\nfunction isStream(o) {\n  return o instanceof stream_1.Readable;\n}","map":{"version":3,"sources":["C:/Users/DELL/OneDrive/Desktop/React/netflix-clone/node_modules/firebase-tools/lib/apiv2.js"],"names":["Object","defineProperty","exports","value","Client","setAccessToken","setRefreshToken","url_1","require","stream_1","ProxyAgent","retry","abort_controller_1","node_fetch_1","util_1","auth","error_1","logger_1","responseToError","pkg","CLI_VERSION","version","accessToken","refreshToken","token","proxyURIFromEnv","process","env","HTTPS_PROXY","https_proxy","HTTP_PROXY","http_proxy","undefined","constructor","opts","urlPrefix","endsWith","substring","length","get","path","options","reqOptions","assign","method","request","post","json","body","patch","put","delete","responseType","resolveOnHTTPError","FirebaseError","exit","internalReqOptions","headers","Headers","addRequestHeaders","addAuthHeader","doRequest","thrown","err","Error","message","original","set","has","isLocalInsecureRequest","getAccessToken","data","access_token","requestURL","versionPath","apiVersion","_a","startsWith","fetchURL","queryParams","URLSearchParams","sp","key","keys","append","queryString","toString","fetchOptions","redirect","compress","proxy","agent","envProxy","signal","reqTimeout","timeout","controller","default","setTimeout","abort","isStream","JSON","stringify","operationOptions","retries","retryCodes","minTimeout","maxTimeout","retryMinTimeout","retryMaxTimeout","operation","Promise","resolve","reject","attempt","currentAttempt","res","logger","debug","logRequest","isAbortError","name","includes","clearTimeout","text","parse","logResponse","status","statusCode","response","_b","queryParamsLog","skipLog","logURL","logBody","bodyToString","resBody","u","URL","protocol","_","inspect","o","Readable"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Client = exports.setAccessToken = exports.setRefreshToken = void 0;\nconst url_1 = require(\"url\");\nconst stream_1 = require(\"stream\");\nconst ProxyAgent = require(\"proxy-agent\");\nconst retry = require(\"retry\");\nconst abort_controller_1 = require(\"abort-controller\");\nconst node_fetch_1 = require(\"node-fetch\");\nconst util_1 = require(\"util\");\nconst auth = require(\"./auth\");\nconst error_1 = require(\"./error\");\nconst logger_1 = require(\"./logger\");\nconst responseToError = require(\"./responseToError\");\nconst pkg = require(\"../package.json\");\nconst CLI_VERSION = pkg.version;\nlet accessToken = \"\";\nlet refreshToken = \"\";\nfunction setRefreshToken(token = \"\") {\n    refreshToken = token;\n}\nexports.setRefreshToken = setRefreshToken;\nfunction setAccessToken(token = \"\") {\n    accessToken = token;\n}\nexports.setAccessToken = setAccessToken;\nfunction proxyURIFromEnv() {\n    return (process.env.HTTPS_PROXY ||\n        process.env.https_proxy ||\n        process.env.HTTP_PROXY ||\n        process.env.http_proxy ||\n        undefined);\n}\nclass Client {\n    constructor(opts) {\n        this.opts = opts;\n        if (this.opts.auth === undefined) {\n            this.opts.auth = true;\n        }\n        if (this.opts.urlPrefix.endsWith(\"/\")) {\n            this.opts.urlPrefix = this.opts.urlPrefix.substring(0, this.opts.urlPrefix.length - 1);\n        }\n    }\n    get(path, options = {}) {\n        const reqOptions = Object.assign(options, {\n            method: \"GET\",\n            path,\n        });\n        return this.request(reqOptions);\n    }\n    post(path, json, options = {}) {\n        const reqOptions = Object.assign(options, {\n            method: \"POST\",\n            path,\n            body: json,\n        });\n        return this.request(reqOptions);\n    }\n    patch(path, json, options = {}) {\n        const reqOptions = Object.assign(options, {\n            method: \"PATCH\",\n            path,\n            body: json,\n        });\n        return this.request(reqOptions);\n    }\n    put(path, json, options = {}) {\n        const reqOptions = Object.assign(options, {\n            method: \"PUT\",\n            path,\n            body: json,\n        });\n        return this.request(reqOptions);\n    }\n    delete(path, options = {}) {\n        const reqOptions = Object.assign(options, {\n            method: \"DELETE\",\n            path,\n        });\n        return this.request(reqOptions);\n    }\n    async request(reqOptions) {\n        if (!reqOptions.responseType) {\n            reqOptions.responseType = \"json\";\n        }\n        if (reqOptions.responseType === \"stream\" && !reqOptions.resolveOnHTTPError) {\n            throw new error_1.FirebaseError(\"apiv2 will not handle HTTP errors while streaming and you must set `resolveOnHTTPError` and check for res.status >= 400 on your own\", { exit: 2 });\n        }\n        let internalReqOptions = Object.assign(reqOptions, {\n            headers: new node_fetch_1.Headers(reqOptions.headers),\n        });\n        internalReqOptions = this.addRequestHeaders(internalReqOptions);\n        if (this.opts.auth) {\n            internalReqOptions = await this.addAuthHeader(internalReqOptions);\n        }\n        try {\n            return await this.doRequest(internalReqOptions);\n        }\n        catch (thrown) {\n            if (thrown instanceof error_1.FirebaseError) {\n                throw thrown;\n            }\n            let err;\n            if (thrown instanceof Error) {\n                err = thrown;\n            }\n            else {\n                err = new Error(thrown);\n            }\n            throw new error_1.FirebaseError(`Failed to make request: ${err.message}`, { original: err });\n        }\n    }\n    addRequestHeaders(reqOptions) {\n        if (!reqOptions.headers) {\n            reqOptions.headers = new node_fetch_1.Headers();\n        }\n        reqOptions.headers.set(\"Connection\", \"keep-alive\");\n        if (!reqOptions.headers.has(\"User-Agent\")) {\n            reqOptions.headers.set(\"User-Agent\", `FirebaseCLI/${CLI_VERSION}`);\n        }\n        reqOptions.headers.set(\"X-Client-Version\", `FirebaseCLI/${CLI_VERSION}`);\n        if (!reqOptions.headers.has(\"Content-Type\")) {\n            if (reqOptions.responseType === \"json\") {\n                reqOptions.headers.set(\"Content-Type\", \"application/json\");\n            }\n        }\n        return reqOptions;\n    }\n    async addAuthHeader(reqOptions) {\n        if (!reqOptions.headers) {\n            reqOptions.headers = new node_fetch_1.Headers();\n        }\n        let token;\n        if (isLocalInsecureRequest(this.opts.urlPrefix)) {\n            token = \"owner\";\n        }\n        else {\n            token = await this.getAccessToken();\n        }\n        reqOptions.headers.set(\"Authorization\", `Bearer ${token}`);\n        return reqOptions;\n    }\n    async getAccessToken() {\n        if (accessToken) {\n            return accessToken;\n        }\n        const data = (await auth.getAccessToken(refreshToken, []));\n        return data.access_token;\n    }\n    requestURL(options) {\n        const versionPath = this.opts.apiVersion ? `/${this.opts.apiVersion}` : \"\";\n        return `${this.opts.urlPrefix}${versionPath}${options.path}`;\n    }\n    async doRequest(options) {\n        var _a;\n        if (!options.path.startsWith(\"/\")) {\n            options.path = \"/\" + options.path;\n        }\n        let fetchURL = this.requestURL(options);\n        if (options.queryParams) {\n            if (!(options.queryParams instanceof url_1.URLSearchParams)) {\n                const sp = new url_1.URLSearchParams();\n                for (const key of Object.keys(options.queryParams)) {\n                    const value = options.queryParams[key];\n                    sp.append(key, `${value}`);\n                }\n                options.queryParams = sp;\n            }\n            const queryString = options.queryParams.toString();\n            if (queryString) {\n                fetchURL += `?${queryString}`;\n            }\n        }\n        const fetchOptions = {\n            headers: options.headers,\n            method: options.method,\n            redirect: options.redirect,\n            compress: options.compress,\n        };\n        if (this.opts.proxy) {\n            fetchOptions.agent = new ProxyAgent(this.opts.proxy);\n        }\n        const envProxy = proxyURIFromEnv();\n        if (envProxy) {\n            fetchOptions.agent = new ProxyAgent(envProxy);\n        }\n        if (options.signal) {\n            fetchOptions.signal = options.signal;\n        }\n        let reqTimeout;\n        if (options.timeout) {\n            const controller = new abort_controller_1.default();\n            reqTimeout = setTimeout(() => {\n                controller.abort();\n            }, options.timeout);\n            fetchOptions.signal = controller.signal;\n        }\n        if (typeof options.body === \"string\" || isStream(options.body)) {\n            fetchOptions.body = options.body;\n        }\n        else if (options.body !== undefined) {\n            fetchOptions.body = JSON.stringify(options.body);\n        }\n        const operationOptions = {\n            retries: ((_a = options.retryCodes) === null || _a === void 0 ? void 0 : _a.length) ? 1 : 2,\n            minTimeout: 1 * 1000,\n            maxTimeout: 5 * 1000,\n        };\n        if (typeof options.retries === \"number\") {\n            operationOptions.retries = options.retries;\n        }\n        if (typeof options.retryMinTimeout === \"number\") {\n            operationOptions.minTimeout = options.retryMinTimeout;\n        }\n        if (typeof options.retryMaxTimeout === \"number\") {\n            operationOptions.maxTimeout = options.retryMaxTimeout;\n        }\n        const operation = retry.operation(operationOptions);\n        return await new Promise((resolve, reject) => {\n            operation.attempt(async (currentAttempt) => {\n                var _a;\n                let res;\n                let body;\n                try {\n                    if (currentAttempt > 1) {\n                        logger_1.logger.debug(`*** [apiv2] Attempting the request again. Attempt number ${currentAttempt}`);\n                    }\n                    this.logRequest(options);\n                    try {\n                        res = await (0, node_fetch_1.default)(fetchURL, fetchOptions);\n                    }\n                    catch (thrown) {\n                        const err = thrown instanceof Error ? thrown : new Error(thrown);\n                        const isAbortError = err.name.includes(\"AbortError\");\n                        if (isAbortError) {\n                            throw new error_1.FirebaseError(`Timeout reached making request to ${fetchURL}`, {\n                                original: err,\n                            });\n                        }\n                        throw new error_1.FirebaseError(`Failed to make request to ${fetchURL}`, { original: err });\n                    }\n                    finally {\n                        if (reqTimeout) {\n                            clearTimeout(reqTimeout);\n                        }\n                    }\n                    if (options.responseType === \"json\") {\n                        const text = await res.text();\n                        if (!text.length) {\n                            body = undefined;\n                        }\n                        else {\n                            try {\n                                body = JSON.parse(text);\n                            }\n                            catch (err) {\n                                this.logResponse(res, text, options);\n                                throw new error_1.FirebaseError(`Unable to parse JSON: ${err}`);\n                            }\n                        }\n                    }\n                    else if (options.responseType === \"xml\") {\n                        body = (await res.text());\n                    }\n                    else if (options.responseType === \"stream\") {\n                        body = res.body;\n                    }\n                    else {\n                        throw new error_1.FirebaseError(`Unable to interpret response. Please set responseType.`, {\n                            exit: 2,\n                        });\n                    }\n                }\n                catch (err) {\n                    return err instanceof error_1.FirebaseError ? reject(err) : reject(new error_1.FirebaseError(`${err}`));\n                }\n                this.logResponse(res, body, options);\n                if (res.status >= 400) {\n                    if ((_a = options.retryCodes) === null || _a === void 0 ? void 0 : _a.includes(res.status)) {\n                        const err = responseToError({ statusCode: res.status }, body) || undefined;\n                        if (operation.retry(err)) {\n                            return;\n                        }\n                    }\n                    if (!options.resolveOnHTTPError) {\n                        return reject(responseToError({ statusCode: res.status }, body));\n                    }\n                }\n                resolve({\n                    status: res.status,\n                    response: res,\n                    body,\n                });\n            });\n        });\n    }\n    logRequest(options) {\n        var _a, _b;\n        let queryParamsLog = \"[none]\";\n        if (options.queryParams) {\n            queryParamsLog = \"[omitted]\";\n            if (!((_a = options.skipLog) === null || _a === void 0 ? void 0 : _a.queryParams)) {\n                queryParamsLog =\n                    options.queryParams instanceof url_1.URLSearchParams\n                        ? options.queryParams.toString()\n                        : JSON.stringify(options.queryParams);\n            }\n        }\n        const logURL = this.requestURL(options);\n        logger_1.logger.debug(`>>> [apiv2][query] ${options.method} ${logURL} ${queryParamsLog}`);\n        if (options.body !== undefined) {\n            let logBody = \"[omitted]\";\n            if (!((_b = options.skipLog) === null || _b === void 0 ? void 0 : _b.body)) {\n                logBody = bodyToString(options.body);\n            }\n            logger_1.logger.debug(`>>> [apiv2][body] ${options.method} ${logURL} ${logBody}`);\n        }\n    }\n    logResponse(res, body, options) {\n        var _a;\n        const logURL = this.requestURL(options);\n        logger_1.logger.debug(`<<< [apiv2][status] ${options.method} ${logURL} ${res.status}`);\n        let logBody = \"[omitted]\";\n        if (!((_a = options.skipLog) === null || _a === void 0 ? void 0 : _a.resBody)) {\n            logBody = bodyToString(body);\n        }\n        logger_1.logger.debug(`<<< [apiv2][body] ${options.method} ${logURL} ${logBody}`);\n    }\n}\nexports.Client = Client;\nfunction isLocalInsecureRequest(urlPrefix) {\n    const u = new url_1.URL(urlPrefix);\n    return u.protocol === \"http:\";\n}\nfunction bodyToString(body) {\n    if (isStream(body)) {\n        return \"[stream]\";\n    }\n    else {\n        try {\n            return JSON.stringify(body);\n        }\n        catch (_) {\n            return util_1.default.inspect(body);\n        }\n    }\n}\nfunction isStream(o) {\n    return o instanceof stream_1.Readable;\n}\n"]},"metadata":{},"sourceType":"script"}