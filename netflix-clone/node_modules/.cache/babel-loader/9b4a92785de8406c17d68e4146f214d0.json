{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst stream_1 = require(\"stream\");\n\nconst crypto_1 = require(\"crypto\");\n\nconst data_uri_to_buffer_1 = __importDefault(require(\"data-uri-to-buffer\"));\n\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\n\nconst debug = debug_1.default('get-uri:data');\n\nclass DataReadable extends stream_1.Readable {\n  constructor(hash, buf) {\n    super();\n    this.push(buf);\n    this.push(null);\n    this.hash = hash;\n  }\n\n}\n/**\n * Returns a Readable stream from a \"data:\" URI.\n */\n\n\nfunction get(_ref, _ref2) {\n  let {\n    href: uri\n  } = _ref;\n  let {\n    cache\n  } = _ref2;\n  return __awaiter(this, void 0, void 0, function* () {\n    // need to create a SHA1 hash of the URI string, for cacheability checks\n    // in future `getUri()` calls with the same data URI passed in.\n    const shasum = crypto_1.createHash('sha1');\n    shasum.update(uri);\n    const hash = shasum.digest('hex');\n    debug('generated SHA1 hash for \"data:\" URI: %o', hash); // check if the cache is the same \"data:\" URI that was previously passed in.\n\n    if (cache && cache.hash === hash) {\n      debug('got matching cache SHA1 hash: %o', hash);\n      throw new notmodified_1.default();\n    } else {\n      debug('creating Readable stream from \"data:\" URI buffer');\n      const buf = data_uri_to_buffer_1.default(uri);\n      return new DataReadable(hash, buf);\n    }\n  });\n}\n\nexports.default = get;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AAEA;;AAEA;;AAEA,MAAMA,KAAK,GAAGC,gBAAY,cAAZ,CAAd;;AAEA,MAAMC,YAAN,SAA2BC,iBAA3B,CAAmC;AAGlCC,cAAYC,IAAZ,EAA0BC,GAA1B,EAAqC;AACpC;AACA,SAAKC,IAAL,CAAUD,GAAV;AACA,SAAKC,IAAL,CAAU,IAAV;AACA,SAAKF,IAAL,GAAYA,IAAZ;AACA;;AARiC;AAenC;;;;;AAGA,SAA8BG,GAA9B,cAEuB;AAAA,MADtB;AAAEC,QAAI,EAAEC;AAAR,GACsB;AAAA,MAAtB;AAAEC;AAAF,GAAsB;;AAEtB;AACA;AACA,UAAMC,MAAM,GAAGC,oBAAW,MAAX,CAAf;AACAD,UAAM,CAACE,MAAP,CAAcJ,GAAd;AACA,UAAML,IAAI,GAAGO,MAAM,CAACG,MAAP,CAAc,KAAd,CAAb;AACAf,SAAK,CAAC,yCAAD,EAA4CK,IAA5C,CAAL,EAEA;;AACA,QAAIM,KAAK,IAAIA,KAAK,CAACN,IAAN,KAAeA,IAA5B,EAAkC;AACjCL,WAAK,CAAC,kCAAD,EAAqCK,IAArC,CAAL;AACA,YAAM,IAAIW,qBAAJ,EAAN;AACA,KAHD,MAGO;AACNhB,WAAK,CAAC,kDAAD,CAAL;AACA,YAAMM,GAAG,GAAGW,6BAAgBP,GAAhB,CAAZ;AACA,aAAO,IAAIR,YAAJ,CAAiBG,IAAjB,EAAuBC,GAAvB,CAAP;AACA;AACD;AAAA;;AApBDY","names":["debug","debug_1","DataReadable","stream_1","constructor","hash","buf","push","get","href","uri","cache","shasum","crypto_1","update","digest","notmodified_1","data_uri_to_buffer_1","exports"],"sources":["../src/data.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}