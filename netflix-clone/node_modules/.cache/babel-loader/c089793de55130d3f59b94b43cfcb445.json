{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { OperatorSubscriber } from './OperatorSubscriber';\nexport function groupBy(keySelector, elementOrOptions, duration, connector) {\n  return operate(function (source, subscriber) {\n    var element;\n\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\n      element = elementOrOptions;\n    } else {\n      duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;\n    }\n\n    var groups = new Map();\n\n    var notify = function (cb) {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n\n    var handleError = function (err) {\n      return notify(function (consumer) {\n        return consumer.error(err);\n      });\n    };\n\n    var groupBySourceSubscriber = new GroupBySubscriber(subscriber, function (value) {\n      try {\n        var key_1 = keySelector(value);\n        var group_1 = groups.get(key_1);\n\n        if (!group_1) {\n          groups.set(key_1, group_1 = connector ? connector() : new Subject());\n          var grouped = createGroupedObservable(key_1, group_1);\n          subscriber.next(grouped);\n\n          if (duration) {\n            var durationSubscriber_1 = new OperatorSubscriber(group_1, function () {\n              group_1.complete();\n              durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();\n            }, undefined, undefined, function () {\n              return groups.delete(key_1);\n            });\n            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));\n          }\n        }\n\n        group_1.next(element ? element(value) : value);\n      } catch (err) {\n        handleError(err);\n      }\n    }, function () {\n      return notify(function (consumer) {\n        return consumer.complete();\n      });\n    }, handleError, function () {\n      return groups.clear();\n    });\n    source.subscribe(groupBySourceSubscriber);\n\n    function createGroupedObservable(key, groupSubject) {\n      var result = new Observable(function (groupSubscriber) {\n        groupBySourceSubscriber.activeGroups++;\n        var innerSub = groupSubject.subscribe(groupSubscriber);\n        return function () {\n          innerSub.unsubscribe();\n          --groupBySourceSubscriber.activeGroups === 0 && groupBySourceSubscriber.teardownAttempted && groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}\n\nvar GroupBySubscriber = function (_super) {\n  __extends(GroupBySubscriber, _super);\n\n  function GroupBySubscriber() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.activeGroups = 0;\n    _this.teardownAttempted = false;\n    return _this;\n  }\n\n  GroupBySubscriber.prototype.unsubscribe = function () {\n    this.teardownAttempted = true;\n    this.activeGroups === 0 && _super.prototype.unsubscribe.call(this);\n  };\n\n  return GroupBySubscriber;\n}(OperatorSubscriber);","map":{"version":3,"mappings":";AAAA,SAASA,UAAT,QAA2B,eAA3B;AACA,SAASC,SAAT,QAA0B,yBAA1B;AACA,SAASC,OAAT,QAAwB,YAAxB;AAEA,SAASC,OAAT,QAAwB,cAAxB;AACA,SAASC,kBAAT,QAAmC,sBAAnC;AAgJA,OAAM,SAAUC,OAAV,CACJC,WADI,EAEJC,gBAFI,EAGJC,QAHI,EAIJC,SAJI,EAI8B;AAElC,SAAON,OAAO,CAAC,UAACO,MAAD,EAASC,UAAT,EAAmB;AAChC,QAAIC,OAAJ;;AACA,QAAI,CAACL,gBAAD,IAAqB,OAAOA,gBAAP,KAA4B,UAArD,EAAiE;AAC/DK,aAAO,GAAGL,gBAAV;AACD,KAFD,MAEO;AACFC,cAAQ,GAAyBD,gBAAgB,SAAjD,EAAUK,OAAO,GAAgBL,gBAAgB,QAAjD,EAAmBE,SAAS,GAAKF,gBAAgB,UAApD;AACD;;AAGD,QAAMM,MAAM,GAAG,IAAIC,GAAJ,EAAf;;AAGA,QAAMC,MAAM,GAAG,UAACC,EAAD,EAAmC;AAChDH,YAAM,CAACI,OAAP,CAAeD,EAAf;AACAA,QAAE,CAACL,UAAD,CAAF;AACD,KAHD;;AAOA,QAAMO,WAAW,GAAG,UAACC,GAAD,EAAS;AAAK,mBAAM,CAAC,UAACC,QAAD,EAAS;AAAK,uBAAQ,CAACC,KAAT,CAAeF,GAAf;AAAmB,OAAlC,CAAN;AAAyC,KAA3E;;AASA,QAAMG,uBAAuB,GAAG,IAAIC,iBAAJ,CAC9BZ,UAD8B,EAE9B,UAACa,KAAD,EAAS;AAIP,UAAI;AACF,YAAMC,KAAG,GAAGnB,WAAW,CAACkB,KAAD,CAAvB;AAEA,YAAIE,OAAK,GAAGb,MAAM,CAACc,GAAP,CAAWF,KAAX,CAAZ;;AACA,YAAI,CAACC,OAAL,EAAY;AAEVb,gBAAM,CAACe,GAAP,CAAWH,KAAX,EAAiBC,OAAK,GAAGjB,SAAS,GAAGA,SAAS,EAAZ,GAAiB,IAAIP,OAAJ,EAAnD;AAKA,cAAM2B,OAAO,GAAGC,uBAAuB,CAACL,KAAD,EAAMC,OAAN,CAAvC;AACAf,oBAAU,CAACoB,IAAX,CAAgBF,OAAhB;;AAEA,cAAIrB,QAAJ,EAAc;AACZ,gBAAMwB,oBAAkB,GAAG,IAAI5B,kBAAJ,CAMzBsB,OANyB,EAOzB;AAGEA,qBAAM,CAACO,QAAP;AACAD,kCAAkB,SAAlB,wBAAkB,WAAlB,GAAkB,MAAlB,uBAAkB,CAAEE,WAApB;AACD,aAZwB,EAczBC,SAdyB,EAiBzBA,SAjByB,EAmBzB;AAAM,2BAAM,CAACC,MAAP,CAAcX,KAAd;AAAkB,aAnBC,CAA3B;AAuBAH,mCAAuB,CAACe,GAAxB,CAA4BpC,SAAS,CAACO,QAAQ,CAACqB,OAAD,CAAT,CAAT,CAA6BS,SAA7B,CAAuCN,oBAAvC,CAA5B;AACD;AACF;;AAGDN,eAAK,CAACK,IAAN,CAAWnB,OAAO,GAAGA,OAAO,CAACY,KAAD,CAAV,GAAoBA,KAAtC;AACD,OA5CD,CA4CE,OAAOL,GAAP,EAAY;AACZD,mBAAW,CAACC,GAAD,CAAX;AACD;AACF,KArD6B,EAuD9B;AAAM,mBAAM,CAAC,UAACC,QAAD,EAAS;AAAK,uBAAQ,CAACa,QAAT;AAAmB,OAAlC,CAAN;AAAyC,KAvDjB,EAyD9Bf,WAzD8B,EA8D9B;AAAM,mBAAM,CAACqB,KAAP;AAAc,KA9DU,CAAhC;AAkEA7B,UAAM,CAAC4B,SAAP,CAAiBhB,uBAAjB;;AAOA,aAASQ,uBAAT,CAAiCU,GAAjC,EAAyCC,YAAzC,EAAuE;AACrE,UAAMC,MAAM,GAAQ,IAAI1C,UAAJ,CAAkB,UAAC2C,eAAD,EAAgB;AACpDrB,+BAAuB,CAACsB,YAAxB;AACA,YAAMC,QAAQ,GAAGJ,YAAY,CAACH,SAAb,CAAuBK,eAAvB,CAAjB;AACA,eAAO;AACLE,kBAAQ,CAACX,WAAT;AAIA,YAAEZ,uBAAuB,CAACsB,YAA1B,KAA2C,CAA3C,IACEtB,uBAAuB,CAACwB,iBAD1B,IAEExB,uBAAuB,CAACY,WAAxB,EAFF;AAGD,SARD;AASD,OAZmB,CAApB;AAaAQ,YAAM,CAACF,GAAP,GAAaA,GAAb;AACA,aAAOE,MAAP;AACD;AACF,GAtHa,CAAd;AAuHD;;AAOD;AAAmCK;;AAAnC;AAAA;;AAIEC,yBAAe,CAAf;AAIAA,8BAAoB,KAApB;;AASD;;AAPCzB;AACE,SAAKuB,iBAAL,GAAyB,IAAzB;AAIA,SAAKF,YAAL,KAAsB,CAAtB,IAA2BK,iBAAMf,WAAN,CAAiBgB,IAAjB,CAAiB,IAAjB,CAA3B;AACD,GAND;;AAOF;AAjBA,EAAmC9C,kBAAnC","names":["Observable","innerFrom","Subject","operate","OperatorSubscriber","groupBy","keySelector","elementOrOptions","duration","connector","source","subscriber","element","groups","Map","notify","cb","forEach","handleError","err","consumer","error","groupBySourceSubscriber","GroupBySubscriber","value","key_1","group_1","get","set","grouped","createGroupedObservable","next","durationSubscriber_1","complete","unsubscribe","undefined","delete","add","subscribe","clear","key","groupSubject","result","groupSubscriber","activeGroups","innerSub","teardownAttempted","__extends","_this","_super","call"],"sources":["C:\\Users\\DELL\\OneDrive\\Desktop\\React\\netflix-clone\\node_modules\\firebase-tools\\node_modules\\rxjs\\src\\internal\\operators\\groupBy.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { ObservableInput, Observer, OperatorFunction, SubjectLike } from '../types';\nimport { operate } from '../util/lift';\nimport { OperatorSubscriber } from './OperatorSubscriber';\n\nexport interface BasicGroupByOptions<K, T> {\n  element?: undefined;\n  duration?: (grouped: GroupedObservable<K, T>) => ObservableInput<any>;\n  connector?: () => SubjectLike<T>;\n}\n\nexport interface GroupByOptionsWithElement<K, E, T> {\n  element: (value: T) => E;\n  duration?: (grouped: GroupedObservable<K, E>) => ObservableInput<any>;\n  connector?: () => SubjectLike<E>;\n}\n\nexport function groupBy<T, K>(key: (value: T) => K, options: BasicGroupByOptions<K, T>): OperatorFunction<T, GroupedObservable<K, T>>;\n\nexport function groupBy<T, K, E>(\n  key: (value: T) => K,\n  options: GroupByOptionsWithElement<K, E, T>\n): OperatorFunction<T, GroupedObservable<K, E>>;\n\nexport function groupBy<T, K extends T>(\n  key: (value: T) => value is K\n): OperatorFunction<T, GroupedObservable<true, K> | GroupedObservable<false, Exclude<T, K>>>;\n\nexport function groupBy<T, K>(key: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K>(\n  key: (value: T) => K,\n  element: void,\n  duration: (grouped: GroupedObservable<K, T>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * ![](groupBy.png)\n *\n * When the Observable emits an item, a key is computed for this item with the key function.\n *\n * If a {@link GroupedObservable} for this key exists, this {@link GroupedObservable} emits. Otherwise, a new\n * {@link GroupedObservable} for this key is created and emits.\n *\n * A {@link GroupedObservable} represents values belonging to the same group represented by a common key. The common\n * key is available as the `key` field of a {@link GroupedObservable} instance.\n *\n * The elements emitted by {@link GroupedObservable}s are by default the items emitted by the Observable, or elements\n * returned by the element function.\n *\n * ## Examples\n *\n * ### Group objects by id and return as array\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { mergeMap, groupBy, reduce } from 'rxjs/operators';\n *\n * of(\n *   {id: 1, name: 'JavaScript'},\n *   {id: 2, name: 'Parcel'},\n *   {id: 2, name: 'webpack'},\n *   {id: 1, name: 'TypeScript'},\n *   {id: 3, name: 'TSLint'}\n * ).pipe(\n *   groupBy(p => p.id),\n *   mergeMap((group$) => group$.pipe(reduce((acc, cur) => [...acc, cur], [])))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'JavaScript'},\n * //   { id: 1, name: 'TypeScript'} ]\n * //\n * // [ { id: 2, name: 'Parcel'},\n * //   { id: 2, name: 'webpack'} ]\n * //\n * // [ { id: 3, name: 'TSLint'} ]\n * ```\n *\n * ### Pivot data on the id field\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { groupBy, map, mergeMap, reduce } from 'rxjs/operators';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * )\n *   .pipe(\n *     groupBy(p => p.id, { element: p => p.name }),\n *     mergeMap(group$ =>\n *       group$.pipe(reduce((acc, cur) => [...acc, cur], [`${group$.key}`]))\n *     ),\n *     map(arr => ({ id: parseInt(arr[0], 10), values: arr.slice(1) }))\n *  )\n *  .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'JavaScript', 'TypeScript' ] }\n * // { id: 2, values: [ 'Parcel', 'webpack' ] }\n * // { id: 3, values: [ 'TSLint' ] }\n * ```\n *\n * @param key A function that extracts the key\n * for each item.\n * @param element A function that extracts the\n * return element for each item.\n * @param duration\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @param connector Factory function to create an\n * intermediate Subject through which grouped elements are emitted.\n * @return A function that returns an Observable that emits GroupedObservables,\n * each of which corresponds to a unique key value and each of which emits\n * those items from the source Observable that share that key value.\n *\n * @deprecated Use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n  connector?: () => Subject<R>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n// Impl\nexport function groupBy<T, K, R>(\n  keySelector: (value: T) => K,\n  elementOrOptions?: ((value: any) => any) | void | BasicGroupByOptions<K, T> | GroupByOptionsWithElement<K, R, T>,\n  duration?: (grouped: GroupedObservable<any, any>) => ObservableInput<any>,\n  connector?: () => SubjectLike<any>\n): OperatorFunction<T, GroupedObservable<K, R>> {\n  return operate((source, subscriber) => {\n    let element: ((value: any) => any) | void;\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\n      element = elementOrOptions;\n    } else {\n      ({ duration, element, connector } = elementOrOptions);\n    }\n\n    // A lookup for the groups that we have so far.\n    const groups = new Map<K, SubjectLike<any>>();\n\n    // Used for notifying all groups and the subscriber in the same way.\n    const notify = (cb: (group: Observer<any>) => void) => {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n\n    // Used to handle errors from the source, AND errors that occur during the\n    // next call from the source.\n    const handleError = (err: any) => notify((consumer) => consumer.error(err));\n\n    // Capturing a reference to this, because we need a handle to it\n    // in `createGroupedObservable` below. This is what we use to\n    // subscribe to our source observable. This sometimes needs to be unsubscribed\n    // out-of-band with our `subscriber` which is the downstream subscriber, or destination,\n    // in cases where a user unsubscribes from the main resulting subscription, but\n    // still has groups from this subscription subscribed and would expect values from it\n    // Consider:  `source.pipe(groupBy(fn), take(2))`.\n    const groupBySourceSubscriber = new GroupBySubscriber(\n      subscriber,\n      (value: T) => {\n        // Because we have to notify all groups of any errors that occur in here,\n        // we have to add our own try/catch to ensure that those errors are propagated.\n        // OperatorSubscriber will only send the error to the main subscriber.\n        try {\n          const key = keySelector(value);\n\n          let group = groups.get(key);\n          if (!group) {\n            // Create our group subject\n            groups.set(key, (group = connector ? connector() : new Subject<any>()));\n\n            // Emit the grouped observable. Note that we can't do a simple `asObservable()` here,\n            // because the grouped observable has special semantics around reference counting\n            // to ensure we don't sever our connection to the source prematurely.\n            const grouped = createGroupedObservable(key, group);\n            subscriber.next(grouped);\n\n            if (duration) {\n              const durationSubscriber = new OperatorSubscriber(\n                // Providing the group here ensures that it is disposed of -- via `unsubscribe` --\n                // wnen the duration subscription is torn down. That is important, because then\n                // if someone holds a handle to the grouped observable and tries to subscribe to it\n                // after the connection to the source has been severed, they will get an\n                // `ObjectUnsubscribedError` and know they can't possibly get any notifications.\n                group as any,\n                () => {\n                  // Our duration notified! We can complete the group.\n                  // The group will be removed from the map in the teardown phase.\n                  group!.complete();\n                  durationSubscriber?.unsubscribe();\n                },\n                // Completions are also sent to the group, but just the group.\n                undefined,\n                // Errors on the duration subscriber are sent to the group\n                // but only the group. They are not sent to the main subscription.\n                undefined,\n                // Teardown: Remove this group from our map.\n                () => groups.delete(key)\n              );\n\n              // Start our duration notifier.\n              groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\n            }\n          }\n\n          // Send the value to our group.\n          group.next(element ? element(value) : value);\n        } catch (err) {\n          handleError(err);\n        }\n      },\n      // Source completes.\n      () => notify((consumer) => consumer.complete()),\n      // Error from the source.\n      handleError,\n      // Free up memory.\n      // When the source subscription is _finally_ torn down, release the subjects and keys\n      // in our groups Map, they may be quite large and we don't want to keep them around if we\n      // don't have to.\n      () => groups.clear()\n    );\n\n    // Subscribe to the source\n    source.subscribe(groupBySourceSubscriber);\n\n    /**\n     * Creates the actual grouped observable returned.\n     * @param key The key of the group\n     * @param groupSubject The subject that fuels the group\n     */\n    function createGroupedObservable(key: K, groupSubject: SubjectLike<any>) {\n      const result: any = new Observable<T>((groupSubscriber) => {\n        groupBySourceSubscriber.activeGroups++;\n        const innerSub = groupSubject.subscribe(groupSubscriber);\n        return () => {\n          innerSub.unsubscribe();\n          // We can kill the subscription to our source if we now have no more\n          // active groups subscribed, and a teardown was already attempted on\n          // the source.\n          --groupBySourceSubscriber.activeGroups === 0 &&\n            groupBySourceSubscriber.teardownAttempted &&\n            groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}\n\n/**\n * This was created because groupBy is a bit unique, in that emitted groups that have\n * subscriptions have to keep the subscription to the source alive until they\n * are torn down.\n */\nclass GroupBySubscriber<T> extends OperatorSubscriber<T> {\n  /**\n   * The number of actively subscribed groups\n   */\n  activeGroups = 0;\n  /**\n   * Whether or not teardown was attempted on this subscription.\n   */\n  teardownAttempted = false;\n\n  unsubscribe() {\n    this.teardownAttempted = true;\n    // We only kill our subscription to the source if we have\n    // no active groups. As stated above, consider this scenario:\n    // source$.pipe(groupBy(fn), take(2)).\n    this.activeGroups === 0 && super.unsubscribe();\n  }\n}\n\n/**\n * An observable of values that is the emitted by the result of a {@link groupBy} operator,\n * contains a `key` property for the grouping.\n */\nexport interface GroupedObservable<K, T> extends Observable<T> {\n  /**\n   * The key value for the grouped notifications.\n   */\n  readonly key: K;\n}\n"]},"metadata":{},"sourceType":"module"}